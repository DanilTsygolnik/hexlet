## Lesson 4

В этой практике вы увидите одно из применений глобального изменяемого состояния (когда таковое всё же применяют): глобальный реестр классов. Этот реестр позволяет зарегистрировать некие классы в одном месте программы, а потом получить доступ ко всем зарегистрированным классам в любом участке кода.
src/registry.py

В этом модуле находится реализация глобального реестра классов. В этот реестр любой класс можно добавить с помощью функции registry.add, а уже зарегистрированные классы можно всегда найти в словаре registry.CLASSES. Выглядит использование реестра так:

```python
import registry

class Foo:
    pass


registry.add(Foo)
registry.CLASSES  # {'__main__.Foo': <class '__main__.Foo'>}
```

Содержимое модуля (?) registry:
```python
# Линтер предупреждает об использовании изменяемых объектов в роли констант,
# поэтому приходится заглушить это предупреждение.
CLASSES = {}  # noqa: WPS407


def add(clazz):
    # слово clazz часто используется, чтобы называть переменную, которая
    # ссылается на некий класс. Оригинальное слово "class" в качестве переменной
    # использовать нельзя, потому что в языке уже есть такое ключевое слово.
    # атрибут `clazz.__module__` хранит строку с именем модуля,
    # в котором класс был (изначально) объявлен
    # атрибут `clazz.__name__` хранит строку с именем класса
    key = f'{clazz.__module__}.{clazz.__name__}'
    CLASSES[key] = clazz
```

Шаблон решения:
```python
class Cat:  # noqa: WPS306
    legs = 4


class Bird:  # noqa: WPS306
    legs = 2


# BEGIN (write your solution here)

# END
```

Задание: воспользовавшись шаблоном, зарегистрировать классы Cat и Bird в реестре. Тесты будут проверять, что классы успешно зарегистрированы.

[Решение](prac_lesson4.py) 

## Lesson 5

Цель упражнения состоит в реализации цветовой модели RGB в виде класса с именем… RGB!

Класс должен объявлять три атрибута: red, green и blue, имеющие по умолчанию значение 0. Также вам нужно будет объявить в модуле переменные red, green и blue, ссылающиеся каждая на свой экземпляр класса RGB. При этом у объекта в red атрибут red должен быть равен 255. Тем же образом нужно модифицировать и объекты в blue и green.

При верной реализации должен заработать код ниже:
```python
import prac_lesson5.py


def rgb2tuple(rgb):
    if isinstance(rgb, solution.RGB):
         return rgb.red, rgb.green, rgb.blue

 
rgb2tuple(42) # ничего не возвращает
rgb2tuple(solution.red)  # (255, 0, 0)
rgb2tuple(solution.green)  # (0, 255, 0)
rgb2tuple(solution.blue)  # (0, 0, 255)
```

[Модуль с решением](prac_lesson5.py)

## Lesson 6

Реализуйте класс Counter, представляющий собой счётчик, хранящий неотрицательное целочисленное значение и позволяющий это значение изменять:
- атрибут value должен хранить текущее значение счётчика (вначале равное нулю);
- метод inc(delta=1) должен увеличивать текущее значение на delta единиц (на 1 по умолчанию);
- метод dec(delta=1) должен уменьшать текущее значение на delta единиц.

[Модуль с решением](prac_lesson6.py)
[Модуль с тестами](test_prac_lesson6.py)

## Lesson 7

Требуется снова реализовать класс Counter.

Но на этот раз счётчик будет иммутабельный (и всё ещё неотрицательный целочисленный): методы inc и dec должны возвращать новый счётчик с изменённым значением. Атрибут value всё ещё должен содержать текущее значение.

В этой реализации нужно объявить в классе инициализатор, позволяющий задать начальное значение счётчика (атрибут value). Если же значение при инстанциировании не будет задано, следует принять его равным нулю.

В самом классе атрибут value не должен быть объявлен. Этот атрибут должен добавляться в объект в инициализаторе. Методы inc(delta=1) и dec(delta=1) должны возвращать новый экземпляр счётчика. Старый же экземпляр не должен изменяться при этом!

[Модуль с решением](prac_lesson7.py)
[Модуль с тестами](test_prac_lesson7.py)

## Lesson 8

Реализуйте класс HourClock, который будет изображать часы с одной лишь часовой стрелкой. Текущее время (час) должно сообщать свойство hours. Это же свойство должно позволять изменять текущее время (посредством сеттера). При изменении положения стрелки нужно контролировать, чтобы значение оставалось в диапазоне 0..11 (часов).

[Модуль с решением](prac_lesson8.py)
[Модуль с тестами](test_prac_lesson8.py)

## Lesson 9

Вам дан класс Counter, реализующий счётчик с инкрементом и декрементом. Вам нужно реализовать класс-потомок LimitedCounter, который будет отличаться от Counter тем, что при инициализации будет принимать в качестве аргумента лимит — максимальное возможное значение счётчика.

Требования к классу LimitedCounter:
- Класс должен максимально использовать методы предка, если таковые переопределяет.
- Минимальное значение счётчика Counter — 0, должно оставаться таковым и для LimitedCounter.

[Модуль с решением](prac_lesson9.py)
[Модуль с тестами](test_prac_lesson9.py)

## Lesson 10

Реализуйте декоратор suppress ("подавлять"), который должен перехватывать заданное исключение (одно или несколько), если таковое возникнет при вызове оборачиваемой функции, и возвращать вместо ошибки заданное значение (keyword-only аргумент "or_return", значение по умолчанию — None).

```python
@suppress(ZeroDivisionError, or_return=42)
def foo():
     return 1 // 0
 
foo()  # 42
```

Образец решения:
```python
from functools import wraps


def suppress(exception, *, or_return=None):
    """Suppress exceptions of provided class(es) and return a value instead."""
    def wrapper(function):
        @wraps(function)
        def inner(*args, **kwargs):
            try:
                return function(*args, **kwargs)
            except exception:
                return or_return
        return inner
    return wrapper
```
Материалы по вопросу, которые нашел:
-[статья на Хабре](https://habr.com/ru/post/587066/) 
