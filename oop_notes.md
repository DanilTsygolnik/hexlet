## Для чего программировать в ОО-парадигме

При составлении программ всегда происходит работа на определенном уровне абстракции.

Чем сложнее программа, тем выше сложность кодирования и отладки. Управление сложностью достигается путем деления всего процесса разработки на этапы, каждому из которых соответствует определенный уровень абстракции. Чем более независимы уровни абстракции, тем проще работать. Под независимостью подразумевается, что для понимания происходящего на данном уровне не нужно спускаться/подниматься на другие уровни.

Наглядным примером сложного проекта из реального мира, условно, является самолет:
- на верхнем уровне абстракции мы думаем "как на нем летать?";
- на среднем - "как собрать самолет из запчастей?";
- ниже - "как произвести запчасти?";
- на низшем уровне приходится иметь дело с естественно научными абстракциями (математика, физика и др.), описывающих процессы на стадиях производства и эксплуатации.

_Процедурное программирование_ подразумевает написание программ, в которых процедуры оперируют структурами данных для решения определенных задач.

Под процедурой можно понимать логически обособленную часть программы (модуль, функцию, подпрограмму), выполняющую определенную задачу. Каждая процедура состоит из множества команд, но как все устроено "под капотом" знать не обязательно. Для выполнения определенного действия достаточно вызвать процедуру по имени. Таким образом, мы _абстрагируемся_ от деталей реализации: работаем на более высоком уровне "как пользоваться?", а не на уровне "как это устроено внутри?"

Подобно процедурам, с помощью простых объектов вроде строк и чисел (built-in types) программируются _структуры данных_.

Переход от _императивного программирования_ к _процедурному_ - это переход на более высокий уровень абстракции.

> Введение хорошей абстракции может существенно снизить сложность программы в одном месте без сильного усложнения программы в целом. [^oop-intro: https://ru.hexlet.io/courses/python-oop-basics/lessons/intro/theory_unity]

[^oop-intro]: https://ru.hexlet.io/courses/python-oop-basics/lessons/intro/theory_unity

ООП (объектно-ориентированное программирование) является подходом, упрощающим _процедурное программирование_, т.к. вводит абстракции еще более высокого уровня: процедуры и структуры данных объединяются в _объекты_.

## Концепции ООП [^oop-concepts]

### Инкапсуляция

Абстрагирование в отношении хранения и работы с данными с учетом контекста.

Пример: человек, абстракция - объект "Person". 

У человека могут быть питомцы, он может утратить некоторых, завести новых. В любом случае, наличие питомцев - это характеристика отдельно взятого индивида, данные, с которыми можно работать.

На уровне объектов нам важно, какими свойствами обладает объект, и что с этими данными можно делать. Например, "проверить, есть ли у человека питомцы" или "добавить нового питомца".

На таком уровне нам не важна реализация, мы оперируем сущностями, поэтому лишние подробности можно скрыть (инкапсулировать). Мы абстрагируемся от них, чем облегчаем понимание процессов на данном уровне.

### Полиморфизм

Абстрагирование от особенностей поведения (реализации интерфейса).

Рассуждение в терминах "что нужно сделать?", а не "каким образом это работает?"

Не имеет значения, что за объект программа получает входными данными. Главное - объект включает в себя процеду и структуры данных, предусмотренные программой.

Наглядный пример. Человек может заботиться о питомце:
- питомец-птичка - заботиться значит кормить;
- питомец-робот - заботиться значит менять батарейки;
- питомец-камень - заботиться значит мыть.

### Наследование

Можно ожидать, что для объекты класса-потомка будут обладать свойствами класса-предка.

Абстрагируемся от нюансов, фокус - на ключевых особенностях, которых требует задача.

Например, пусть требуется перевезти льва, тигра или пантеру. Единственное, что в данном случае важно: мы перевозим здоровую кошку (наследник класса "абстрактная кошка", которая охотится и дышит воздухом). Так что для перевозки понадобится большая клетка с толстыми прутьями, а кормить придется мясом. Если бы речь шла о рыбах (наследник класса "абстрактная рыба"), мы воспользовались резервуаром с водой.

Наследование связано с инкапсуляцией: часто достаточно знать, чьим предком является класс объекта, чтобы понять, может ли данная программа работать с такой сущностью.

[^oop-concepts]: [Урок на hexlet](https://ru.hexlet.io/courses/python-oop-basics/lessons/oop-conceptions/theory_unit)

## ООП в Python

Реализация через создание объектов-классов и инстанцирования.

### Классы. Атрибуты.

Объявление класса в Python:  [^docstrings-example1]
```python
# простейший класс
class PrimitiveClass:
    pass

class Person:
    '''Класс для хранения данных человека

    Attributes:
        name (str): person's name.
    '''
    name = 'Noname'
```

[^docstrings-example1]: https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html

Для объявленного класса создается объект:
```python
Person # <class '__main__.Person'>
```

Инстанцирование - создание экземпляра класса: [^instances-hexlet]
```python
person_noname = Person()
person_noname # <__main__.Person object at 0x7f529d8a6dd0>
```

[^instances-hexlet]: https://ru.hexlet.io/courses/python-oop-basics/lessons/instances/theory_unit

Каждый класс является отдельными [пространствами имен](namespaces.md).  Имена атрибутов классов и объектов хранятся в атрибуте `__dict__`: название атрибута - ключ в словаре.
```python

Person.__dict__ # mappingproxy({'__module__': '__main__', 'name': 'Noname', '__dict__': <attribute '__dict__' of 'Person' objects>, '__weakref__': <attribute '__weakref__' of 'Person' objects>, '__doc__': None})

person_noname.__dict__ # {}
```

После изменения значений атрибутов экземпляр класса становится отдельным пространством имен (??).

`__dict__` позволяет вручную добавлять новые атрибуты экземпляру класса:
```python
person_bob, person_claire = Person(), Person()
person_bob.name = "Bob"
person_claire.name = "Claire"

# добавляем атрибут "фамилия"
person_claire.__dict__['surname'] = "Redfield"

# сравниваем
person_noname.__dict__ # {}
person_bob.__dict__ # {'name': 'Bob'}
person_claire.__dict__ # {'name': 'Claire', 'surname': 'Redfield'}
```

Работа с классами и объектами:
```python
# Инстанцирование (создание экземпляров класса)
person_bob = Person()

# работа с атрибутами, как с глобальными переменными
person_bob.name = 'Bob'
```

Проверить, к какому классу принадлежит объект, можно двумя способами:
```python
# способ 1
person_bob.__class__ # <class '__main__.Person'>

# способ 2, рекомендованный
isinstance(person_bob, Person) # True
```

### Методы

Если атрибут класса указывает на функцию, его называют _методом_. 

```python
class Foo:
    def bar():
        pass


x = Foo()
x
# <__main__.Foo object at 0x7f7beca78668>

Foo.bar
# <function Foo.bar at 0x7f7bee2d1d08>

x.bar
# <bound method Foo.bar of <__main__.Foo object at 0x7f7beca78668>>
```

Различают:
- несвязанные методы класса - как обычная функция. Например: `list.append(list_instance, what_to_append)`;
- связанные методы класса - используют данные объекта, обращение к ним происходит через параметр `self`: `person_bob.get_full_name()`

```python
class Person:
    name = 'Noname'
    def greet(self):
        print(f'Hello, {self.name}!')


person_bob = Person()
person_bob.name = 'Bob'
person_bob.greet()
# => Hello, Bob!
person_noname = Person()
person_noname.greet()
# => Hello, Noname!
```

#### Инициализация

Связанный dunder-метод `__init__()` помогает настраивать экземпляры класса (переписывать значения атрибутов) после инстанцирования.
```python
class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

bob = Person("Bob", "Smith")
bob.__dict__ # {'name': 'Bob', 'surname': 'Smith'}
```

`__init__` — не конструктор! [^init-hexlet]

[^init-hexlet]: https://ru.hexlet.io/courses/python-oop-basics/lessons/methods/theory_unit

Конструкторы в языках программирования, поддерживающих ООП, именно создают экземпляры: выделяют память под объект, возвращают ссылку на этот объект. То есть до вызова конструктора экземпляр не существует. dunder-init же получает ссылку на **уже существующий объект** в аргументе self.

Рассмотрим такой код:
```python
bob = Person('Bob')
Person.__init__(bob, 'Mike')
bob.name  # 'Mike'
```
dunder-init всего лишь изменяет существующий объект. А был бы он конструктором, мы бы получили новый экземпляр класса Person.

#### Протоколы

Это связанные dunder-методы, программирующие класс на определенное поведение.

Пример:
```python
class Road:
    def __init__(self, length_km, material):
        self.length = length_km
        self.pavement = material

    def __len__(self):
        return self.length


# класс Road работает с протоколом __len__,
# поэтому есть возможность использовать функцию len()
sand_road = Road(100, "sand")
len(sand_road) # 100
```

"Duck typing" -- 

## TODOs

что такое `__main__` (см. `<class '__main__.Person'>`)
"Duck typing" (см. протоколы)
свойства, setters, getters, deleters
наследование
исключения -- в ветку по тестированию
